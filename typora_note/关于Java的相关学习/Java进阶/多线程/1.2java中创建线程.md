

# 1.第一种创建线程的方法

""

```
package com.guigu.java;

/*
* 多线程的创建方式
* 方式 继承于 Thread 类
* 1：创建一个继承于Thread类的子类
* 2。重写 Thread类的 run方法   -->此线程执行的操作 声明在run中
*3。创建Thread类的子类的对象
* 4。通过对象调用 start
*
* 例子：遍历100内所有的偶数
*
* */


class MyThread extends Thread{
    //重写run()


    @Override
    public void run() {
        for (int i=0;i<100;i++)
        {
            if(i%2==0)
            {
                System.out.println(Thread.currentThread().getName()+i);
            }
        }
    }
}


public class ThreadTest {
    public static void main(String[] args) {
        //3.创建子类的对象
        MyThread ti=new MyThread();

        //4.通过此对象调用 start（）:1,启动当前的线程 2，调用当前线程的 Run（）方法
        ti.start();

        //能不能通过调run？？  不行 会先执行run 方法 之后再调用 主线程的方法
        //问题1 我们不能通过直接调用run方法的方式 启动线程

        //问题2：再启动一个线程 遍历100以内的偶数
        //        ti.start();
        //对于一个线程而言 我们只能调用一次 start 。我们不能让一个已经start的线程去start
        //只能 再创建一个t2
        MyThread t2=new MyThread();
        t2.start();

        //如下的操作仍然是在main线程中执行的
        System.out.println("hello");
        for (int i=0;i<100;i++)
        {
            if(i%2==1)
            {
                System.out.println(Thread.currentThread().getName()+i+"main  =====");
            }
        }




    }
}
```



```
package com.guigu.exer;


/*
* 创建两个分线程，其中一个遍历100以内的偶数，另一个比那里100以内的奇数
*
* */


public class ThreadDemo {
    public static void main(String[] args) {
        MyThread m1=new MyThread();
//
//        MyThread2 m2=new MyThread2();
//
//        m1.start();
//        m2.start();

        //创建 Thread类的匿名子类的方式

        new Thread(){
            @Override
            public void run() {
                for (int i=0;i<100;i++)
                {
                    if(i%2==0)
                    {
                        System.out.println(Thread.currentThread().getName()+i);
                    }
                }
            }
        }.start();
        
    }
}


class MyThread extends Thread{
    @Override
    public void run() {
        for (int i=0;i<100;i++)
        {
            if(i%2==0)
            {
                System.out.println(Thread.currentThread().getName()+i);
            }
        }
    }
}


class MyThread2 extends Thread{
    @Override
    public void run() {
        for (int i=0;i<100;i++)
        {
            if(i%2==1)
            {
                System.out.println(Thread.currentThread().getName()+i);
            }
        }
    }
}
```



# 2.Thread 类的相关方法

![image-20210203150915443](/Users/xuhan/Library/Application Support/typora-user-images/image-20210203150915443.png)

""

```
package com.guigu.java;


/*
* Thread 中常用的方法:
* 1.start()：启动当前的线程 调用当前线程的run()
* 2.run():通常要求重写Thread 的run() 将创建的线程要执行的操作声明在此方法当中
* 3 。 currentThread ():静态方法 返回当前代码执行的线程
* 4。getName（） ：获取当前线程的名字
* 5.setName() :设置当前线程的名字
*   6.yield():释放当前CPU的执行权，当然有可能又被这个线程给抢走了
*   7。join():在线程a中调用线程b的join方法，此时线程a进入了阻塞状态，直到我们的线程b完全执行完之后，线程a才
*   结束阻塞状态。
*
*   8。stop ：不建议这样去结束线程
*   9.sleep() :让当前线程睡眠 其实就是阻塞 指定多少到ms  当前线程是阻塞状态
*   10。isAlive（）：判断线程是否存活
*
*
*
*
* */

public class ThreadMethodTest {
    public static void main(String[] args) throws InterruptedException {
        HelloThread h1=new HelloThread("Thread:1-");//这边通过构造器命名
//        h1.setName("线程1"); 这里通过方法命名
        h1.start();


        //给主线程 进行一个改名
        Thread.currentThread().setName("主线程");
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + i);
            }

//            h1.join();
        }


    }
}


class HelloThread extends Thread {

    public HelloThread(String name)
    {
        super(name);
    }


    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {

                try {
                    sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }


                System.out.println(Thread.currentThread().getName() + i);
            }

//            if(i%20==0)
//            {
//                this.yield();//释放当前cpu 但是不一定会被别的线程抢到
//                //Thread.currentThread().yield();
//            }
//


        }
    }
}
```



# 线程的调度

![image-20210203154539610](/Users/xuhan/Library/Application Support/typora-user-images/image-20210203154539610.png)





![image-20210203154923935](/Users/xuhan/Library/Application Support/typora-user-images/image-20210203154923935.png)

""

```
package com.guigu.java;


/*
* Thread 中常用的方法:
* 1.start()：启动当前的线程 调用当前线程的run()
* 2.run():通常要求重写Thread 的run() 将创建的线程要执行的操作声明在此方法当中
* 3 。 currentThread ():静态方法 返回当前代码执行的线程
* 4。getName（） ：获取当前线程的名字
* 5.setName() :设置当前线程的名字
*   6.yield():释放当前CPU的执行权，当然有可能又被这个线程给抢走了
*   7。join():在线程a中调用线程b的join方法，此时线程a进入了阻塞状态，直到我们的线程b完全执行完之后，线程a才
*   结束阻塞状态。
*
*   8。stop ：不建议这样去结束线程
*   9.sleep() :让当前线程睡眠 其实就是阻塞 指定多少到ms  当前线程是阻塞状态
*   10。isAlive（）：判断线程是否存活
*
*
*   线程的优先级
public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;

    如何获取和设置当前线程的优先级：
    getPriority():获取线程的优先级
    setPriority(int p):设置线程的优先级

    高优先级线程会抢占低优先级的执行权 但是只是草你个概率上来说 并不意味着 高优先级执行完之后低优先级才执行

*
*
*
*
* */

public class ThreadMethodTest {
    public static void main(String[] args) throws InterruptedException {
        HelloThread h1=new HelloThread("Thread:1-");//这边通过构造器命名
//        h1.setName("线程1"); 这里通过方法命名

        //设置分线程的优先级  可以看到并不是优先级高 就先执行它了
        h1.setPriority(Thread.MAX_PRIORITY);
        h1.start();


        //给主线程 进行一个改名
        Thread.currentThread().setName("主线程");
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() +"："+ Thread.currentThread().getPriority()+":"+ i);
            }

//            h1.join();
        }


    }
}


class HelloThread extends Thread {

    public HelloThread(String name)
    {
        super(name);
    }


    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {

//                try {
//                    sleep(1000);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }


                System.out.println(Thread.currentThread().getName() + i);
            }

//            if(i%20==0)
//            {
//                this.yield();//释放当前cpu 但是不一定会被别的线程抢到
//                //Thread.currentThread().yield();
//            }
//


        }
    }
}
```

# 4.第二种创建线程的方式 runnabel

```
package com.guigu.java;



/*
* 例子 创建三个窗口买票 总票数100张
*
* 会出现线程安全问题：待解决
*第二种创建的方式
*
*
*
* */

class Window extends Thread{

    private static int tickets=100;


    @Override
    public void run() {
        while (true)
        {
            if(tickets>0)
            {
                System.out.println(Thread.currentThread().getName()+" 票为:"+tickets);
                tickets--;
            }else
            {
                break;
            }
        }
    }
}


public class WindowTest {
    public static void main(String[] args) {
        Window t1=new Window();
        Window t2=new Window();
        Window t3=new Window();

        t1.setName("w1");
        t2.setName("w2");
        t3.setName("w3");


        t1.start();
        t2.start();
        t3.start();
    }
}
```



""

```
package com.guigu.java;


/*
* 创建多线程的方式2 ： 实现Runnable借口
* 1。创建一个实现了 Runnable接口的类
* 2。实现类趋势线Runnable中的抽象方法 fun
* 3。创建实现类的对象
* 4。通过将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
* 5。通过 Thread 类的对象 调用start
*
*
*比较创建线程的两种方式
* 第二种好一点，
* 1。因为第一种会继承Thread，java是单继承单方式
* 2。 自然而然单实现了 static 共享数据的方式 不需要加static
*
* 比较两种方式：
* 开发中优先选择 实现Runnable接口的方式
* 原因：1。实现的方式没有类的单继承的局限性
*      2。实现方式更适合来处理多线程 有共享数据的情况
* 联系：Thread类也是runnable接口的实现
* 相同点：两种方法都需要重写 run（） 将线程要执行的逻辑声明在run中
*
*
*
*
* */

public class ThreadTest1 {
    public static void main(String[] args) {
        //3.创建实现类的对象
        MThread m1=new MThread();
        //4, 将此对象作为参数传递到Thread类的构造器中 创建Thread类的对象
        Thread t1 = new Thread(m1);

        //5.通过Thread类的对象调用 start()  启动线程 调用当前线程的run()-->调用了Runnable类型的target的run
        //Thread run里面有一个 Runnable 的构造函数 会调用target 的run
        t1.setName("线程1");
        t1.start();



        //在启动一个线程 遍历100以内的偶数
        Thread t2 = new Thread(m1);
        
        t2.start();
    }
}


class MThread implements Runnable{

    @Override
    public void run() {
        for (int i=0;i<100;i++)
        {
            if(i%2==0)
            {
                System.out.println(Thread.currentThread().getName()+i);
            }
        }

    }
}
```

""

```
package com.guigu.java;



/*
*
*用 Runnable的方式实现我们的买票
*
*
* */

class Window1 implements Runnable{

    private int tickets=100; //这里不需要static
    @Override
    public void run() {
        while (true)
        {
            if(tickets>0)
            {
                System.out.println(Thread.currentThread().getName()+" 票为:"+tickets);
                tickets--;
            }else
            {
                break;
            }
        }
    }
}


public class WindowTest1 {

    public static void main(String[] args) {

        Window1 w1=new Window1();
        //我这边只有一个对象 所以不需要加static

        Thread t1=new Thread(w1);
        Thread t2=new Thread(w1);
        Thread t3=new Thread(w1);


        t1.start();
        t2.start();
        t3.start();




    }
}
```

# 5.线程的生命周期

![image-20210203165101654](/Users/xuhan/Library/Application Support/typora-user-images/image-20210203165101654.png)



![image-20210203165553425](/Users/xuhan/Library/Application Support/typora-user-images/image-20210203165553425.png)

# 6.线程的同步

<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210203165812065.png" alt="image-20210203165812065" style="zoom:33%;" />

操作共享数据的时候 会产生安全问题



```java
package com.guigu.java;



/*
* 例子 创建三个窗口买票 总票数100张
*
* 会出现线程安全问题：待解决
*继承的方法：因为每一个都new 了一个对象，所以obj必须得是static的，才能保证都是一样的obj
*
*说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，
*
* */

class Window extends Thread{

    private static int tickets=100;
    private static Object obj=new Object();


    @Override
    public void run() {
        while (true)
        {
            synchronized(Window.class){//类也是对象  Window.class也是唯一的 只会加载一次
						//错误的方式：用this 因为是生成了三个新的对象  
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }


            if(tickets>0)
            {
                System.out.println(Thread.currentThread().getName()+" 票为:"+tickets);
                tickets--;
            }else
            {
                break;
            }
            }
        }
    }
}


public class WindowTest {
    public static void main(String[] args) {
        Window t1=new Window();
        Window t2=new Window();
        Window t3=new Window();

        t1.setName("w1");
        t2.setName("w2");
        t3.setName("w3");


        t1.start();
        t2.start();
        t3.start();
    }
}


```



```java
package com.guigu.java;



/*
*
*用 Runnable的方式实现我们的买票
*
* 1。问题：买票过程中出现了重票、错票的过程
* 2。重票和错票的原因：当某个线程操作车票的过程中，尚未操作完成的，其他线程也参与了进来操作车票
*
* 3。如何解决？
* 当一个线程a在操作ticket的时候，其它线程不能参与进来，只有a操作完的时候，其它线程才能参与进来
*
* 4。在java中 我们通过同步机制来解决线程的安全问题。
*
* 方式一：同步代码块
* synchronized(同步监视器)
* {
*           //需要被同步的代码
* }
*
* 说明：1.操作共享数据的代码。即为需要被同步的代码  ->不能包含多了 也不能包含少了
*    2. 共享数据：多个线程共同操作的变量。比如 ：tickets
*    3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。
*       要求：多个线程必须要用同一把锁  如果把obj 放在run 里面 那每个线程都是有一个锁
*
* 5.同步的方式，解决了线程的安全性问题----好处
*   操作同步代码的时候，只有一个线程参与，其它线程等待，相当于是一个单线程的过程
*
*   补充：



*   方便的方法：
*   Runnable方法实现多线程的过程中：当前对象 我们用This  我们只用一个window1的对象
*   继承方法：但是还有一种方法就不能写成this了
*   还有中得用 Window.class 类也是对象  有一个类叫Class class=Window2.class
*
*
*
*
*
*
* 方式二：同步方法
*
* */

class Window1 implements Runnable{

    private int tickets=100; //这里不需要static
    //Object obj=new Object();



    @Override
    public void run() {
       // Object obj=new Object();
				
      //这个不能放在while true 外面 放外面就是包多了 就是一个线程进来 就是一顿wile 别的线程只能等着
      //所以应该把 synchornized放在while里面
        //synchronized(this){//这里的this是window1 是唯一的一个对象
        while (true)
        {
          synchronized(this){//这里的this是window1 是唯一的一个对象

            //加了这个之后 错票和假票会经常出现  加了这个之后 概率会提升
//            try {
//                Thread.sleep(100);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }

            if(tickets>0)
            {
                System.out.println(Thread.currentThread().getName()+" 票为:"+tickets);
                tickets--;
            }else
            {
                break;
            }
        }
        }
    }
}


public class WindowTest1 {

    public static void main(String[] args) {

        Window1 w1=new Window1();
        //我这边只有一个对象 所以不需要加static

        Thread t1=new Thread(w1);
        Thread t2=new Thread(w1);
        Thread t3=new Thread(w1);


        t1.start();
        t2.start();
        t3.start();


    }
}


class Dog{

}
```

# 7.同步方法处理实现Runnable的线程安全问题

```java
package com.guigu.java;

/**
 * 使用同步方法处理继承Thread类的方式中的线程安全问题
 *
 * @author shkstart
 * @create 2019-02-15 上午 11:43
 */
class Window4 extends Thread {


    private static int ticket = 100;

    @Override
    public void run() {

        while (true) {

            show();
        }

    }
    private static synchronized void show(){//同步监视器：Window4.class
//        private synchronized void show(){ //这里是this 同步监视器：t1,t2,t3。此种解决方式是错误的
        if (ticket > 0) {

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + "：卖票，票号为：" + ticket);
            ticket--;
        }
    }
}


public class WindowTest4 {
    public static void main(String[] args) {
        Window4 t1 = new Window4();
        Window4 t2 = new Window4();
        Window4 t3 = new Window4();


        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();

    }
}
```

```java
package com.guigu.java;
/**
 * 使用同步方法解决实现Runnable接口的线程安全问题
 *
 *
 *  关于同步方法的总结：
 *  1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
 *  2. 非静态的同步方法，同步监视器是：this
 *     静态的同步方法，同步监视器是：当前类本身
 *
 * @author shkstart
 * @create 2019-02-15 上午 11:35
 */


class Window3 implements Runnable {

    private int ticket = 100;

    @Override
    public void run() {
        while (true) {

            show();
        }
    }

    private synchronized void show(){//同步监视器：this
        //synchronized (this){

        if (ticket > 0) {

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);

            ticket--;
        }
        //}
    }
}


public class WindowTest3 {
    public static void main(String[] args) {
        Window3 w = new Window3();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }

}
```

# 8.线程安全的单例模式：懒汉模式

```java
package com.guigu.java1;


/**
 * 使用同步机制将单例模式中的懒汉式改写为线程安全的
 *
 * @author shkstart
 * @create 2019-02-15 下午 2:50
 */
public class BankTest {

}

class Bank{

    private Bank(){}

    private static Bank instance = null;//先不创建 看你之后需不需要再创建 这是懒汉

    public static Bank getInstance(){  //或者直接 public synchronized static Bank
        //方式一：效率稍差 比如现在有多个线程 第一个人先抢到了iphone 拿到了从后们走了
        // 其实别的人就不需要让前面等了，现在这个还是需要一个进去 再告诉他们没有了 再走
//        synchronized (Bank.class) {
//            if(instance == null){//instance是共享数据
//
//                instance = new Bank();
//            }
//            return instance;
//        }
        //方式二：效率更高
        if(instance == null){//立个牌子 说我们的手机没有了

            synchronized (Bank.class) {
                if(instance == null){

                    instance = new Bank();
                }

            }
        }
        return instance;
    }

}

```

# 9.死锁问题

<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210207095707174.png" alt="image-20210207095707174" style="zoom:50%;" />

<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210207104625301.png" alt="image-20210207104625301" style="zoom:50%;" />



```java
package com.guigu.java1;


/**
 * 演示线程的死锁问题
 *
 * 1.死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，
 * 都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
 *
 * 2.说明：
 * 1）出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
 * 2）我们使用同步时，要避免出现死锁。
 *
 */

public class ThreadTest {

    public static void main(String[] args) {

        StringBuffer s1=new StringBuffer();
        StringBuffer s2=new StringBuffer();


        new Thread(){
            @Override
            public void run() {
                synchronized (s1)
                {
                   s1.append("a");
                   s2.append("1");

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    synchronized (s2)
                   {
                       s1.append("b");
                       s2.append("2");

                       System.out.println(s1);
                       System.out.println(s2);
                   }
                }

            }
        }.start();



        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (s1)
                {
                    s1.append("c");
                    s2.append("3");

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }



                    synchronized (s2)
                    {
                        s1.append("d");
                        s2.append("4");

                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }



            }
        }).start();


    }
}

```



# 10.Lock锁的方式

![image-20210207113735154](/Users/xuhan/Library/Application Support/typora-user-images/image-20210207113735154.png)

```java
package com.guigu.java1;



import java.util.concurrent.locks.ReentrantLock;

/**
 * 解决线程安全问题的方式三：Lock锁  --- JDK5.0新增
 *
 * 1. 面试题：synchronized 与 Lock的异同？
 *   相同：二者都可以解决线程安全问题
 *   不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器
 *        Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）
 *
 * 2.优先使用顺序：
 * Lock  同步代码块（已经进入了方法体，分配了相应资源）  同步方法（在方法体之外）
 *
 *
 *  面试题：如何解决线程安全问题？有几种方式
 * @author shkstart
 * @create 2019-02-15 下午 3:38
 */
class Window implements Runnable{

    private int ticket = 100;
    //1.实例化ReentrantLock
    private ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() {
        while(true){
            try{

                //2.调用锁定方法lock() 下面的全部保证是单线程的
                lock.lock();

                if(ticket > 0){

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.out.println(Thread.currentThread().getName() + "：售票，票号为：" + ticket);
                    ticket--;
                }else{
                    break;
                }
            }finally {//没有异常 所以直接 finally
                //3.调用解锁方法：unlock()
                lock.unlock();
            }

        }
    }
}

public class LockTest {
    public static void main(String[] args) {
        Window w = new Window();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

```

## 10.1 练习题

```java
package com.atguigu.exer;

/**
 * 银行有一个账户。
 有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。

    分析：
 1.是否是多线程问题？ 是，两个储户线程
 2.是否有共享数据？ 有，账户（或账户余额）
 3.是否有线程安全问题？有
 4.需要考虑如何解决线程安全问题？同步机制：有三种方式。

 * @author shkstart
 * @create 2019-02-15 下午 3:54
 */
class Account{
    private double balance;

    public Account(double balance) {
        this.balance = balance;
    }

    //存钱
    public synchronized void deposit(double amt){//这里的this是 account 所以用的是同一个this
        if(amt > 0){
            balance += amt;

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + ":存钱成功。余额为：" + balance);
        }
    }
}

class Customer extends  Thread{

    private Account acct;

    public Customer(Account acct) {
        this.acct = acct;
    }

    @Override
    public void run() {

        for (int i = 0; i < 3; i++) {
            acct.deposit(1000);
        }

    }
}


public class AccountTest {

    public static void main(String[] args) {
        Account acct = new Account(0);
        Customer c1 = new Customer(acct);
        Customer c2 = new Customer(acct);

        c1.setName("甲");
        c2.setName("乙");

        c1.start();
        c2.start();
    }
}

```



# 11.线程的通信（wait）

用两个线程打印1-100.线程1 线程2 交替打印

```java
package java2;

/*
*线程通信的例子：使用两个线程打印 1-100。线程1, 线程2 交替打印
*
*  涉及到的三个方法：
 * wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
 * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。
 * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。
*
*说明：
*1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。
*2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。
 *    否则，会出现IllegalMonitorStateException异常 也就是不能synchronized（obj） 然后this.notify 必须是两者一致
 * 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 因为要保证任何一个对象都能调用
*
*
* 面试题：sleep() 和 wait()的异同？
 * 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。
 * 2.不同点：1）两个方法声明的位置不同：Thread类中声明静态的sleep() , Object类中声明wait()
 *          2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中
 *          3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。
 *
*
*
* */



class Number implements Runnable{

    private int number=1;

    @Override
    public void run() {
        while (true)
        {
            synchronized (this)
            {

                notify();//这边只有两个线程 所以只要一个就行了  线程1 wait 2 进来给1唤醒 但是我2拿着钥匙 你1进不来
                if(number<100)
                {
                    System.out.println(Thread.currentThread().getName()+":"+number);
                    number++;

                    try {
                        wait();//使得如下调用 wait方法的线程进入阻塞状态 释放锁 1才能进来
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }


                }else
                {
                    break;
                }
            }

        }

    }
}





public class CommunicationTest {

    public static void main(String[] args) {
        Number number=new Number();

        Thread t1=new Thread(number);
        Thread t2=new Thread(number);


        t1.setName("线程1");
        t2.setName("线程2");

        t1.start();
        t2.start();


    }
}

```

# 12.生产者消费者问题

<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210207223158622.png" alt="image-20210207223158622" style="zoom:50%;" />

```java
package java2;

/*
 * 线程通信的应用：经典例题：生产者/消费者问题
 *
 * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，
 * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员
 * 会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品
 * 了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。
 *
 * 分析：
 * 1. 是否是多线程问题？是，生产者线程，消费者线程
 * 2. 是否有共享数据？是，店员（或产品）
 * 3. 如何解决线程的安全问题？同步机制,有三种方法
 * 4. 是否涉及线程的通信？是
*
* */



class Clerk{
    private int productNum=0;

    //生产产品
    public synchronized void produceProduct() {//当我们生产者进来 它拿着clerk的this 消费者是进不去的

        if(productNum<20)
        {
            productNum++;
            System.out.println(Thread.currentThread().getName()+"：开始生产第"+productNum+"个产品");
            //我们生产了一个产品 就能唤醒消费者了

            notify();
        }else
        {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

//    消费产品
    public synchronized void consumeProduct() {
        if(productNum>0)
        {
            System.out.println(Thread.currentThread().getName()+"开始消费第"+productNum+"个产品");
            productNum--;

            //当我们消费了一个产品 我们就能唤醒生产者去继续生产了
            notify();

        }else
        {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}

class Producer extends Thread{//生产者

    private Clerk clerk;

    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName() + ":开始生产产品.....");

        while(true){

            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.produceProduct();
        }

    }
}




class Comsumer extends Thread{

    private Clerk clerk;


    public Comsumer(Clerk clerk)
    {
        this.clerk=clerk;
    }

    @Override
    public void run() {

        while (true)
        {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.consumeProduct();
        }


    }
}

public class ProductTest {
    public static void main(String[] args) {
        Clerk clerk=new Clerk();

        Producer p1=new Producer(clerk);
        p1.setName("生产者");


        Comsumer c1=new Comsumer(clerk);
        c1.setName("消费者");

        Comsumer c2=new Comsumer(clerk);
        c2.setName("消费者");


        p1.start();
        c1.start();
        c2.start();

    }
}

```

# 13.Callable接口和线程池 回调方法

![image-20210207230421679](/Users/xuhan/Library/Application Support/typora-user-images/image-20210207230421679.png)

```java
package com.atguigu.java2;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * 创建线程的方式三：实现Callable接口。 --- JDK 5.0新增
 *
 *
 * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
 * 1. call()可以有返回值的。
 * 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
 * 3. Callable是支持泛型的
 *
 * @author shkstart
 * @create 2019-02-15 下午 6:01
 */
//1.创建一个实现Callable的实现类
class NumThread implements Callable{
    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            if(i % 2 == 0){
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}


public class ThreadNew {
    public static void main(String[] args) {
        //3.创建Callable接口实现类的对象
        NumThread numThread = new NumThread();
        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
        new Thread(futureTask).start();

        try {
            //6.获取Callable中call方法的返回值
            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
            Object sum = futureTask.get();
            System.out.println("总和为：" + sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

}

```

# 14.线程池

![image-20210207232405026](/Users/xuhan/Library/Application Support/typora-user-images/image-20210207232405026.png)

手机划图片，一个个造线程，会很麻烦

![image-20210207232908190](/Users/xuhan/Library/Application Support/typora-user-images/image-20210207232908190.png)

```java
package com.atguigu.java2;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * 创建线程的方式四：使用线程池
 *
 * 好处：
 * 1.提高响应速度（减少了创建新线程的时间）
 * 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）
 * 3.便于线程管理
 *      corePoolSize：核心池的大小
 *      maximumPoolSize：最大线程数
 *      keepAliveTime：线程没有任务时最多保持多长时间后会终止
 *
 *
 * 面试题：创建多线程有几种方式？四种！
 * @author shkstart
 * @create 2019-02-15 下午 6:30
 */

class NumberThread implements Runnable{

    @Override
    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

class NumberThread1 implements Runnable{

    @Override
    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

public class ThreadPool {

    public static void main(String[] args) {
        //1. 提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        //这个接口属性比较少


        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
        //设置线程池的属性
//        System.out.println(service.getClass());
//        service1.setCorePoolSize(15);
//        service1.setKeepAliveTime();// 活跃的时间


        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread());//适合适用于Runnable
        service.execute(new NumberThread1());//适合适用于Runnable

//        service.submit(Callable callable);//适合使用于Callable
        //3.关闭连接池
        service.shutdown();
    }

}

```



# 15.其它题目

1.画图说明线程的生命周期，以及各个状态切换使用到的方法等

状态，相应的方法。

状态A切换到B，哪些方法执行了（回调方法）

某个方法主动调用：状态A->B

3.阻塞：临时状态，不可能作为最终的状态

![image-20210208093113765](/Users/xuhan/Library/Application Support/typora-user-images/image-20210208093113765.png)

2.同步代码块中涉及同步监视器和共享数据，谈谈对同步监视器和共享数据的理解

sychronized。同步监视器：必须保证是同一个同步监视器

共享数据：多个线程共同操作的数据

<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210208092955865.png" alt="image-20210208092955865" style="zoom: 50%;" />

![image-20210208094244489](/Users/xuhan/Library/Application Support/typora-user-images/image-20210208094244489.png)

![image-20210208094310720](/Users/xuhan/Library/Application Support/typora-user-images/image-20210208094310720.png)