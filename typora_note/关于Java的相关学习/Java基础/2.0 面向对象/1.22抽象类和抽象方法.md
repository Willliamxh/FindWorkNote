![image-20210204191510337](/Users/xuhan/Library/Application Support/typora-user-images/image-20210204191510337.png)

不能创建对象的类，abstract。想要创建对象，必须得通过子类继承

""

```java
package com.guigu.java;
/*
* Abstract
*  abstract 关键字的使用
*  1。abstract 抽象的
*  2。abstract 可以用来修饰类的结构：类、方法
* 3。 abstract 修饰的类： 抽象的类 不能构建实例
*    >类不能实例话
*    >抽象类中一定有构造函数，便于子类实例化时候的调用 （涉及：子类对象实例话的过程）
*    >开发中都是提供抽象类的子类 让子类实例话 完成相关操作
*
*
* 4.abstract 修饰方法
*   抽象方法所在的类必须是个抽象类
*   >抽象方法中只有方法的声明，没有方法体
*   >包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。
*   >若子类重写了父类中所有的抽象方法后，此子类方可实例化
*     若子类没有重写父类中所有的方法，则此子类也是一个抽象类，需要用abstract来修饰
*
*
*     比如不同的图形求面积的公式是不一样的，那我们开始的时候就不知道该怎么写，于是我们就把它设置成
*     一个抽象类

* */

/*
* abstract使用上的注意点
*
* 1。abstract 不能用来修饰：属性、构造器等结构
* 2。abstract 不能用来修饰：私有方法 （因为子类没发重写私有的）、静态方法（静态方法不能被重写）、
*                          final方法（也是不能被重写）、final的类

* */


abstract class  Creature{
    public abstract void breath();


}

public class AbstractTest {

    public static void main(String[] args) {
        //一旦Person类抽象了 就不能被实例化了
    }
}



abstract class Person extends Creature{

    String name;
    int age;
    public Person()
    {

    }


    //空方法不是抽象方法
//    public void eat(){
////        System.out.println("eat");
//
//    }

    public abstract void eat();

    public void walk()
    {
        System.out.println("walk");
    }
}


class Student extends Person{
    public Student()
    {

    }
    public void eat(){
        System.out.println("eat");
    }

    @Override
    public void breath() {
        System.out.println("breath");
    }
}
```



抽象类的应用：

<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210204193510011.png" alt="image-20210204193510011" style="zoom: 50%;" />

<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210204193530172.png" alt="image-20210204193530172" style="zoom:50%;" />

![image-20210204204012492](/Users/xuhan/Library/Application Support/typora-user-images/image-20210204204012492.png)

是的

# 2.创建抽象类的匿名子类

<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210204204406136.png" alt="image-20210204204406136" style="zoom: 50%;" />



<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210204204625342.png" alt="image-20210204204625342" style="zoom:50%;" />



<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210204204649856.png" alt="image-20210204204649856" style="zoom:50%;" />

<img src="/Users/xuhan/Library/Application Support/typora-user-images/image-20210204204809509.png" alt="image-20210204204809509" style="zoom:50%;" />

![image-20210204205437872](/Users/xuhan/Library/Application Support/typora-user-images/image-20210204205437872.png)

# 3.多态的应用：模版方法设计模式

![image-20210205111332062](/Users/xuhan/Library/Application Support/typora-user-images/image-20210205111332062.png)

""

```java
package com.guigu.java;
//模版方法
public class TemplateTest {


    public static void main(String[] args) {
        Template t=new SubTemplate();


        t.spendTime();//code那边调用的是子类的code
    }
}

abstract class Template{

    public void spendTime(){
        long start=System.currentTimeMillis();
        code();//不确定的部分 易变的部分  像个勾子一样勾到哪个子类 就实现哪个子类的方法  回调函数

        long end=System.currentTimeMillis();

        System.out.println("time cost="+(end -start));

    }

    public abstract void code();

}

class SubTemplate extends Template{

    @Override
    public void code() {
        for(int i=2;i<1000;i++)
        {
            boolean isFlag=true;
            for(int j=2;j<=Math.sqrt(i);j++)
            {
                if(i%j==0)
                {
                    isFlag=false;
                    break;
                }
            }
            if(isFlag)
            {
                System.out.println(i);
            }

        }
    }
}
```







