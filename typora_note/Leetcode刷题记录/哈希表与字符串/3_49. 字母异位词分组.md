<img src="3_49. 字母异位词分组.assets/image-20201130150925857.png" alt="image-20201130150925857" style="zoom: 50%;" />

思路：
这题还是使用map
由于这边是只要字母一样就能归为一类，所以我们要把同一类的字符串作为一个key的话不是很好办；

所以我们在判断这个字符串是否是属于同一类之前，现将他们排个序，我们将排序后的字符串作为key就能顺利解决这个问题了。

那map对应的value就应该是ArrayList,存储这这个key对应的字符串

最后返回的时候记得加上new ArrayList 不然collection无法满足需求

排序代码

```

char tempstr[]=strs[i].toCharArray();
Arrays.sort(tempstr);//排序
 //这边记得要转string
String tempKey=String.valueOf(tempstr);//坑点3这边得把排序好的char转为String 这边记得char[] 转String 得用valueOf
//这边的tempKey 和 strs[i]是完全不同的地址了
```

然后 代码：

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res=new ArrayList<List<String>>();
        //方法1先对输入的数组进行一个排序 然后将排序的数组看看在不在
        if(strs.length==0)//坑点4 这边记得要判断String的length
        {
            return res;
        }
        HashMap<String,List<String>> mapRes=new HashMap<>();
        for(int i=0;i<strs.length;i++)
        {
//            System.out.println();
            char tempstr[]=strs[i].toCharArray();
            Arrays.sort(tempstr);//排序
            //这边记得要转string
            String tempKey=String.valueOf(tempstr);//坑点3这边得把排序好的char转为String 这边记得char[] 转String 得用valueOf
            if(mapRes.containsKey(tempKey))
            {
                mapRes.get(tempKey).add(strs[i]);//由于是引用直接加进去
//                continue;
            }else
            {
                //如果不包括这个key了 那就新建一个key
                mapRes.put(tempKey,new ArrayList());//新建一个头
                mapRes.get(tempKey).add(strs[i]);//坑点2 这边如果不包括key 不仅要新建一个头 还得把我们的内容给add进去
            }
           
            // System.out.println(new ArrayList(mapRes.values()));
        }
        // System.out.println(mapRes.values());
        return new ArrayList(mapRes.values());//这边不用new的话 返回的是list//坑点 1 这边，values返回的是个collection 不是list
        //关于这边需要new ArrayList的解答
        //https://www.cnblogs.com/chengpeng15/p/5804376.html

    }
}
```

