![image-20210829230816133](106.从中序与后序遍历构造二叉树.assets/image-20210829230816133.png)

树的还原过程描述
根据中序遍历和后续遍历的特性我们进行树的还原过程分析

首先在后序遍历序列中找到根节点(最后一个元素)
根据根节点在中序遍历序列中找到根节点的位置
根据根节点的位置将中序遍历序列分为左子树和右子树
根据根节点的位置确定左子树和右子树在中序数组和后续数组中的左右边界位置
递归构造左子树和右子树
返回根节点结束

过程：
inorder：[9,3,15,20,7]
postorder：[9,15,7,20,3]

根节点：3
9,     **3,**    15,20,7
9,15,7,20,         3

9,     3,      15,   **20,**   7
9,15,7,      **20,**         3
……

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    HashMap<Integer, Integer> hashMap=new HashMap<Integer,Integer>();
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        
        //将对应的inorder的值 和 index 放在hashMap中
        for (int i = 0; i < inorder.length; i++) {
            hashMap.put(inorder[i],i);
        }
        TreeNode res = getBinaryTree( postorder, 
                0, inorder.length - 1, 
                0, postorder.length - 1);
        return res;

    }

    public TreeNode getBinaryTree(int[] postorder,
                                  int inOrderStartIndex,int inOrderEndIndex,
                                  int postOrderStartIndex,int postOrderEndIndex){
        if(inOrderStartIndex>inOrderEndIndex||postOrderStartIndex>postOrderEndIndex){
            return null;
        }
        //每次取出后序遍历的最后一个 做为根节点
        int rootValue = postorder[postOrderEndIndex];
        //然后根据根节点的值，找到中序遍历的那个index 将中序遍历分为左右两个part
        int rootIndexInOrder = hashMap.get(rootValue);
        
        TreeNode root = new TreeNode(rootValue);
        // System.out.println(root.val);
        // System.out.println("postOrderEndIndex:"+postOrderEndIndex);
        //然后分别得到左右子树
        root.left = getBinaryTree( postorder,
                inOrderStartIndex, rootIndexInOrder - 1,
                postOrderStartIndex, postOrderStartIndex + (rootIndexInOrder - 1 - inOrderStartIndex));
        
        root.right=getBinaryTree( postorder,
                rootIndexInOrder+1, inOrderEndIndex,
                postOrderStartIndex + (rootIndexInOrder - 1 - inOrderStartIndex)+1, postOrderEndIndex-1);
        
        return root;
    }
}

```

