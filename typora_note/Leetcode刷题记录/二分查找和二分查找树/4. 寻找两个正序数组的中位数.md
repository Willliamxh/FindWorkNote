<img src="4. 寻找两个正序数组的中位数.assets/image-20210112211007168.png" alt="image-20210112211007168" style="zoom:50%;" />

这题是一题二分的题目。然后中途还通过linweiwei的教程去复习了一下二分的使用方法。复习到这一题的时候，请务必先自己动手写一下。因为之前自己的想法好像是错误的。

参考知识：

边界设置的两种写法：

right = mid 和 left = mid + 1 和 int mid = left + (right - left) / 2; 一定是配对出现的；
right = mid - 1 和 left = mid 和 int mid = left + (right - left + 1) / 2; 一定是配对出现的。


链接：https://leetcode-cn.com/leetbook/read/learning-algorithms-with-leetcode/xs41qg/

<img src="4. 寻找两个正序数组的中位数.assets/image-20210115095932642.png" alt="image-20210115095932642" style="zoom:50%;" />



参考题解：

https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/



https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/

```java
public class Solution {

    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        //划分两个数组的边界 让两个数组的左边有  nums1.length + nums2.length +1 /2 个数
        // 6 +4 +1 /2=5 我们这边对短的进行二分 所以 应该是
        // 1 2 3 4 |5 6  nums2 是长的
        // --------
        //|2 3 4 5        nums1 是短的
        //然后对 i 进行判断 这个时候 i=0   left=0 right=nums1.length 注意没有减一 因为我们的分界线能到边界的
        // 我们开始用二分查找排除错误的因素。 因为原来的条件是 num1[i-1]<=nums2[j]&&nums[i]>=nums[j-1]
        // 我们排除错误条件 那就是取反：num1[i-1]>nums2[j]||nums[i]<nums[j-1] 的时候 我们取另一半 mid=left+(right-left)/2  之后 left =mid+1 或者 right=mid
        //按照上面的情况 left初始化为0  right初始化为nums1.length  mid=(left+right)/2= (0+4)/2 =2  i=2 j=(nums1.length + nums2.length +1 /2)-2=5-2=3
        //1 2 3 |4 5 6  nums2 是长的
        //    --
        //2 3 |4 5        nums1 是短的
        //这个时候 判断 是否 nums[i]<nums[j-1]  不是 这个时候说明满足情况 那我们就考虑能不能把i变小一点 看看依旧不满足条件 也就是把分割线往左边调一下 也就是取左半边
        //注意这边不能判断num1[i-1]>nums2[j] 因为有可能出现nums.length =1 的时候 那如果 这个时候 i=0 那nums[-1] 就越界了
        //right = i  这个时候 left =0 right=2  mid=1  i=1 j=5-1=4

        //1 2 3 4| 5 6  nums2 是长的
        //   ----
        //2 |3 4 5        nums1 是短的

        //这个时候 还是 nums[i]<nums[j-1] 3<4  是这个情况 那我们就得让i 大一点 取右边
        //left=i+1=1+1=2  这个时候 right=2 退出循环
        //那这个时候
        //1 2 3 |4 5 6  nums2 是长的
        //    --
        //2 3 |4 5        nums1 是短的 就是这么个样子 也就是我们的最终状态
        //这个时候 我们取中位数 如果不考虑边界情况的话 我们就直接根据length来判断 length=10 也就是我们需要取cut左边最大的和右边最小的
        // 也就是 max(nums1[i-1],nums12[j-1]) +min(nums1[i],nums12[j])
        //根据以上的逻辑 我们开始写代码
        //首先我们将nums1变为长度小的那个
        if(nums1.length>nums2.length)
        {
            int temp[]=nums1;
            nums1=nums2;
            nums2=temp;
        }

        int nums1Length=nums1.length;
        int nums2Length=nums2.length;

        int rangeLen=(nums1Length+nums2Length+1)/2;
        //开始二分查找
        int left=0;
        int right=nums1Length;

        while (left<right)
        {
             int mid=left+(right-left)/2;
             int cutNums1=mid;
             int cutNums2=rangeLen-cutNums1;

             if(nums1[cutNums1]<nums2[cutNums2-1]) //说明我的i太小了 我要取大一点
             {
                 left=cutNums1+1;
             }else
             {
                 right=cutNums1;
             }
        }
        //这里结束之后 找到了正确的cut点了 left==right
        int cut1=left;
        int cut2=rangeLen-cut1;
        int nums1LeftMax;
        int nums2LeftMax;
        int nums1RightMin;
        int nums2RightMin;
		
        //接下来这边是为了判断cut再边界时候的情况 当cut=0的时候，左边没有数字，那我们就将左边设定为最小值，因为我们需要取得左边的最大值 那这个数肯定不会被取到
        if(cut1==0)
        {
            nums1LeftMax=Integer.MIN_VALUE;
        }else
        {
            nums1LeftMax=nums1[cut1-1];
        }

        if(cut1==nums1Length)
        {
            nums1RightMin=Integer.MAX_VALUE;
        }else {
            nums1RightMin=nums1[cut1];
        }

        if(cut2==0)
        {
            nums2LeftMax=Integer.MIN_VALUE;
        }else
        {
            nums2LeftMax=nums2[cut2-1];
        }

        if(cut2==nums2.length)
        {
            nums2RightMin=Integer.MAX_VALUE;
        }else
        {
            nums2RightMin=nums2[cut2];
        }

        if((nums1Length+nums2Length)%2==0)
        {
            //偶数
            return (Math.max(nums1LeftMax,nums2LeftMax)+Math.min(nums1RightMin,nums2RightMin))/2.0;
        }else
        {
            return Math.max(nums1LeftMax,nums2LeftMax);
        }
    }
}


```

