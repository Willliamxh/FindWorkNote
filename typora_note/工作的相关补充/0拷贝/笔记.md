笔记1：1 要把内存数据发送到网卡然后发出去时：

没有DMA时候怎么办：CPU读**内存**数据到**CPU的高速缓存**，再写到网卡。这样就把CPU的速度拉低到和网卡一个速度。

有了DMA：把内存数据读到socket内核缓存区（CPU复制），CPU就不管了，告诉DMA开始接管。DMA开始把内核缓冲区的数据写到网卡。DMA读socket缓冲区，读到DMA缓冲区，然后写到网卡中。不停写到网卡。

DMA发送完后，DMA中断CPU，（这样CPU就知道socket内核缓冲区又空出来了），CPU从用户态切换到内核态，执行中断处理程序，将socket缓冲区阻塞的进程移回到运行队列。

比如要发送的数据是100k，但是内核缓冲区就50k，这样第二次50k也能发出去了。2 读硬件时：

CPU检查内核缓冲区里是否有指定的数据，直接就可以读。如果没有，CPU就交给DMA，DMA负责把硬盘读到缓冲区，然后告诉CPU移动完了，然后把阻塞的进程再移动到运行队列。3 状态切换：

\- 用户空间：用户代码、用户堆栈
\- 内核空间：内核代码、内核调度程序、进程描述符（内核堆栈、thread_info进程描述符）
  \- 进程描述符和用户的进程是一一对应的
  \- SYS_API：系统调用，如read、write
  \- 进程描述符：进程从用户态切换到内核态时，需要保存用户态时的上下文信息，比如：用户程序基地址，程序计数器、cpu cache、寄存器。。。方便程序从内核态切换回用户态时恢复现场。
  \- 内核堆栈：系统调用函数也是要创建变量的，这些变量在内核堆栈上分配，



笔记2：
系统调用：比如用户想要读取硬盘上的文件，发起read调用，这个read只是内核态的库函数api，该库函数会发起系统调用。该库函数里面有80中断，软中断，进程切换到内核态。到cpu里存一个系统调用号（表示哪个系统函数，比如read）。把cpu的临时数据都保存到thread_info中（恢复到用户态时用），然后执行80中断处理程序，找到刚刚存的系统调用号（比如read），先检查缓存中有没有对应的数据，没有就去磁盘中加载到内核缓冲区，然后从内核缓冲区拷贝到用户空间，然后恢复到用户态，恢复现场，用户态就知道从哪继续执行。

缓冲区读写：

\- 读：用户态切换到内核态，先看内核态缓冲区有没有，有就直接读到，没有就交给DMA去读。DMA控制器从磁盘、网卡、其他IO设备中读。CPU在这个期间可以执行其他进程。DMA加载到内核缓冲区后告诉CPU，CPU把数据拷贝到用户态，CPU把该进程从阻塞队列移到到运行队列。
\- 写：缓存区满了之后，写操作阻塞，缓冲区有一个等待队列，记录阻塞的进程（java的轻量级进程），DMA把缓冲区数据写到网卡后告诉CPU，中断CPU，把该进程移动到运行队列。

虚拟内存：

物理内存：类似于大的数组，可以随机读取。

以前单核计算机时只需要保证保证不写内核空间即可。多核计算机引入多进程后，每个进程有自己的用户空间，得防止不能访问其他进程空间。所以引入了虚拟内存。进程分配了虚拟内存，CPU MMU单元可以帮助完成虚拟内存到物理内存的映射。虚拟内存可以大于真实物理内存，MMU可以把不常用的东西从物理内存放到磁盘上（swap区）。因为可以替换，所以不同进程的虚拟内存空间的地址可以映射到用一个物理内存。利用这个特性，可以把用户空间和内核空间的地址翻译为同一块物理内存地址，就可以减少拷贝，即零拷贝的技术。

笔记3：
传统IO：从硬盘读到网卡，从左下到右下。进程去读，先看内核缓冲区有没有，没有就告诉DMA去读到内核缓冲区，然后把进程放到内核的阻塞队列中，DMA读好后发起中断告诉CPU，CPU唤醒阻塞进程，从内核缓冲区读到用户数据缓冲区，然后再切换到内核态进程写操作，写到socket缓冲区后，告诉DMA把socket缓冲区的数据写到网卡。复制了4次，进程切换了4次。
MMAP：DMA把磁盘上的文件映射到内存，用户空间和内核空间共享同一块物理地址，这样就无需进程用户空间和内核空间的来回复制。写到网卡的时候，共享空间的内容拷贝到socket缓冲区（CPU复制），然后告诉DMA发送到网卡。3次复制（2次DMA，一次CPU复制）
sendfile：打开文件的fd+socket的fd告诉sendfile，也是经过和上面一样的3次复制。不过只进程了2次用户态和内核态的切换
NIO：buffer数组，NIO把byte数组的位置和长度发给内核态，内核空间可以访问用户空间，这叫跨传输。如果发送GC，stw，线程都停止，会回收垃圾对象，会进行碎片整理，所以位置会变。NIO选择在堆外创建一个同样大小的buffer，先从用户空间拷贝到堆外空间（cpu拷贝），再发送write系统调用，这时候发送堆外的位置+长度，堆外是不发生GC的，然后再拷贝到内核缓冲区。NIO合理使用堆外内存可以避免堆内到堆外的一次拷贝，可以直接放到堆外buffer。



笔记4：
NIO必然使用了堆外空间：

在NIO中使用了`IOUtil.write()`，会判断是否是堆外内存`if(var instanceof DirectBuffer){return writeFromNativeBuffer();}`，否则是堆内，`Util.getTemporaryDirectorBuffer()`，创建临时堆外空间，大小和当前堆内buffer大小一样大，然后从堆内buffer拷贝到堆外buffer ： `var堆外.put(var堆内)`，然后`writeFromNativeBuffer()`，从堆外写到内核缓冲区。

如何释放堆外空间：

合理使用堆外内存可以减少拷贝。但是堆外不受JVM管理，如何释放？JVM中根据可达性算法从根对象跟踪引用对象。JVM的栈里指向了一个堆内的对象，该堆内对象指向堆外内存，该堆内对象代理操作堆外内存。如果不可达了后，判断该代理对象成为垃圾，回收的时候会去释放堆外空间。

DirectByteBuffer.java：

构造函数中用`unsafe.allocate(size)`分配堆外内存，返回堆外地址base。`unsafe.setMemory(base,size,0)`将该堆外空间初始化置位0。然后创建Cleaner对象`Cleaner.create(this堆外内存引用,new Deallocator(base,size,cap))`负责清理堆外内存。里面传了个Deallocator释放器，他的run()里有`unsafe.freeMemeory(address)`。

Cleaner继承了PhantomReference虚引用。



笔记5：引用有：强、软、虚、弱四种引用。

栈里存的是栈帧（即方法），有的强引用直接指向obj，也有的强引用指向ref，ref实例存放到堆，ref再指向obj。这个ref指的是除了强引用外的引用，不是我们写的a = new A(),b=a;这还是强引用

\- Soft软引用情况下，强引用置位null时，gc时可能就释放了obj。
  \- 软引用不一定被回收
\- Weak弱引用情况下，强引用置为null时，gc一定回收obj
  \- `buffer = new buffer()`，然后`weakRef = new WeakReference(buffer,refQueue)`，然后`buffer=null`失去强引用，只剩下了一个弱引用，GC之前`weakReference.get()`可以拿到obj对象引用，GC之后`weakReference.get()`为null。但是GC之前引用队列refQueue里`refQueue.poll()`为null，GC之后refQueue中获取的ref = refQueue.poll()和weakRef一致，即被回收以后就把weakRef加入到refQueue，所以GC之后的`refQueue.poll()==weakRef`。也就是说这个引用队列知道谁被回收了，weakHashmap就是利用这种方式清空无效的kv对
\- Phantom虚引用情况下，通过虚引用get永远是null，当强引用变为null时，gc一定回收obj。虚引用的作用是创建虚引用时，可以传给一个引用对象，当obj被GC时，就可以在引用队列里找到虚引用
  \- 构造方法必须传引用队列`RefQueue`。
  \- GC之前引用队列里为null，get也返回null。GC之后refQueue.poll()有了虚引用，get还是null。源码中get都返回null：`PhantomRef.get(){return null;}`
所以说Ref所指向的对象再GC时，根可达性算法不管他，obj还是会被回收



笔记6：
Reference：

四种状态：

\- Active：激活。创建ref对象时就是激活状态
\- Pending：等待入队。所对应的强引用被GC，就要入队，是GC线程做的
\- Enqueued：入队了。守护线程，
  \- 如果指定了refQueue消费pending移动到enqueued状态。refQueue.poll时进入失效状态
  \- 如果没有指定refQueue，直接到失效状态。
\- Inactive：失效

\```java
public class Reference{

​	ref属性：保存真实对象引用。

​	queue属性：指定引用队列（虚引用必须指定）

​	next属性：指向下一个ref，单向链表

​	discovered属性：VM线程使用。来判定当前ref的真实对象是垃圾后，会将当前ref加入到pending队列，然后JM把discovered连接起来组成pending链表

​	static pending属性：是一个ref链表。所以说多个堆内对象的ref就可以组合到pending中。GC线程操作的
​        
​    static{
​        handler = new ReferenceHandler();
​        handler.setDaemon(true);
​        handler.start();
​    }
}



笔记7
接上面代码
private class ReferenceHandler extends Thread{
    public void run(){
        // Cleaner
        // 为什么需要同步？
        //1．jvm及收玺器线程能要向pending队列追加ref
	    //2．当前线程狴这个pending队列
        // if(pending!=null){pending先进后出;判断当前元素是不是Cleaner，继承了虚引用;pending出队;}
        // else{阻塞等待gc线程唤醒，gc向pending队列添加新ref之后会notify}
        // if(Cleaner类型){c.clean(); return;}
        // else{获取创建ref时指定的refQueue，如果指定了就入队;return;}
        tryHandlePending(true);
    }
    
}
\```回到之前NIO的堆外内存，就是利用虚引用，上面有一个c.clean()负责释放堆外空间（里面有deallocate释放器），不会执行refQueue入队操作，所以在cleaner里引用队列没有用，但是因为虚引用必须传引用队列，所以new了个static引用队列占坑。

然后NIO的channel与堆外buffer打交道，堆外buffer与内核缓冲区打交道。堆外是为了传buffer位置的时候不受GC垃圾整理影响。

