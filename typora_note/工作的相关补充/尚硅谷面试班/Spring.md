![image-20210321164441039](Spring.assets/image-20210321164441039.png)





# 1.Spring AOP顺序

https://blog.csdn.net/wyn_365/article/details/113545148

![image-20210321164549329](Spring.assets/image-20210321164549329.png)

## 1.1AOP常用注解：

![image-20210321164630881](Spring.assets/image-20210321164630881.png)



## 1.2面试题

![image-20210321164832716](Spring.assets/image-20210321164832716.png)

## 1.3业务类

![image-20210321165001221](Spring.assets/image-20210321165001221.png)





## 1.5Spring4

![image-20210321165210112](Spring.assets/image-20210321165210112.png)

![image-20210321165725387](Spring.assets/image-20210321165725387.png)

![image-20210321165812192](Spring.assets/image-20210321165812192.png)

## 1.6 Spring5（最后的都是after）

正常：

![image-20210321170125286](Spring.assets/image-20210321170125286.png)

异常：

![image-20210321170232267](Spring.assets/image-20210321170232267.png)



before afterreturning  after

# 2.Spring的循环依赖

## 2.1 大厂面试复盘

你解释下spring中的三级缓存？三个Map又什么不同？
什么是循环依赖？IOC容器是神魔？
如何检测是否存在循环依赖？循环依赖的异常见过吗？
多例情况下，循环依赖为神魔无法解决？
spring源码看过没？

## 2.2 什么是循环依赖？

![image-20210322091712990](Spring.assets/image-20210322091712990.png)

#### 就是多个bean之间相互依赖，形成了一个闭环。

#### ![image-20210322091657768](Spring.assets/image-20210322091657768.png)一般默认在单例模式中，属性相互影响的场景。

<img src="Spring.assets/image-20210322091837630.png" alt="image-20210322091837630" style="zoom:33%;" />

## 2.3 依赖注入的两种方式？

![image-20210322092727642](Spring.assets/image-20210322092727642.png)

![image-20210322092739961](Spring.assets/image-20210322092739961.png)



### 1.构造方法注入【不适合解决循环依赖】

![在这里插入图片描述](Spring.assets/20210202173836776.png)

![在这里插入图片描述](Spring.assets/20210202173843591.png)

构造方法错误测试：

![在这里插入图片描述](Spring.assets/20210202173946571.png)

构造器循环依赖是无法解决的，如果想让构造器支持循环依赖，是不可能的。





### 2.set方法注入

![在这里插入图片描述](Spring.assets/20210202173408817.png)



![在这里插入图片描述](Spring.assets/20210202174231247.png)

![在这里插入图片描述](Spring.assets/20210202174221721.png)

set方法解决循环依赖测试：

![在这里插入图片描述](Spring.assets/20210202174335867.png)

作为属性进行注入，解决问题，验证了官网的set方法解决循环依赖的问题。

![image-20210322093908091](Spring.assets/image-20210322093908091.png)



## 2.4 容器内部 使用Spring 3级缓存 解决循环依赖的三个map

![image-20210322094201968](Spring.assets/image-20210322094201968.png)

所谓的3级缓存其实就是spring内部3个用来解决spring循环依赖的3个Map。

![在这里插入图片描述](Spring.assets/20210202175655321.png)

一级缓存：存放已经经历了完整的生命周期的Bean对象。（成品）
二级缓存：存放早期暴露出来的Bean对象，生命周期还没有结束。（半成品 实例化了 没装修）
三计缓存：存放可以生成Bean的工厂 。（还没有实例化）
注意：只有单利的Bean会通过三计缓存来解决循环依赖的问题，不是单利的，每次容器中都会从容器中获取到一个新的对象，重新创建，所以不史丹利的bean时没有的缓存的，不会将其放到三计缓存中去。

### 3.5 Spring循环依赖Debug

知识准备：
实例化：申请内存空间
初始化：属性的赋值

![image-20210322094725382](Spring.assets/image-20210322094725382.png)

![在这里插入图片描述](Spring.assets/2021020218110184.png)

AB两个对象在三级缓存中的迁移说明
1.A的创建过程需要B，于是A将自己放到三级缓存里面（我先要有a），去实例化B（我a里面要有个b）。
2.B实例化时候发现需要A，于是B先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了A。然后把三级缓存里面的这个A放到二级缓存里面，并删除三级缓存里面的A。
3.B顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A依然是创建状态中）然后回来接着创建A，此时B已经创建结束，直接从一级缓存理念拿到B，然后创建完成，并将自己A放到一级缓存里面去。![在这里插入图片描述](Spring.assets/20210203091916382.png)

![在这里插入图片描述](Spring.assets/20210203091516406.png)



#### 3.5.1 开始debug断点调试

![在这里插入图片描述](Spring.assets/20210202193433111.png)

![在这里插入图片描述](Spring.assets/20210202194115111.png)

reflash ：加载容器初始化



![在这里插入图片描述](Spring.assets/20210202194452906.png)

![在这里插入图片描述](Spring.assets/20210202194912138.png)

![在这里插入图片描述](Spring.assets/20210202195150217.png)

![在这里插入图片描述](Spring.assets/20210202195848961.png)









## 2.6 总结spring如何解决循环依赖的?

Spring创建bean主要分为两个步骤，创建原始bean对象，接着去填充对象的属性和初始化
每次创建bean之前，我们都会从缓存中查看有没有该bean，单例只有一个
当我们创建beanA对象之后，并把它放到三级缓存中，接下来就是填充对象属性了，这个时候发现了依赖于B，接着有去创建beanB。
不同的是：
这时候可以在三级缓存总查到刚放进去的beanA，所以不需要继续创建，用它继续注入beanB，完成B的创建，继而继续完成A的属性填充和剩余逻辑。

![image-20210322101447178](Spring.assets/image-20210322101447178.png)

![在这里插入图片描述](Spring.assets/20210203101216718.png)

<img src="Spring.assets/20210203101237900.png" alt="在这里插入图片描述" style="zoom:67%;" />

![在这里插入图片描述](Spring.assets/20210203101620962.png)

![在这里插入图片描述](Spring.assets/20210203101814423.png)

![在这里插入图片描述](Spring.assets/20210203101932404.png)



















