

![image-20210310105352046](JMM内存模型.assets/image-20210310105352046.png)

![image-20210310105413145](JMM内存模型.assets/image-20210310105413145.png)

![image-20210310105747938](JMM内存模型.assets/image-20210310105747938.png)



<img src="JMM内存模型.assets/image-20210310133928426.png" alt="image-20210310133928426" style="zoom:50%;" />

![image-20210905141342221](JMM内存模型.assets/image-20210905141342221.png)

<img src="JMM内存模型.assets/image-20210310133947752.png" alt="image-20210310133947752" style="zoom:50%;" />

所有的变量都存在主内存中。
每个线程，都是去主内存那边进行拷贝一份，到自己的内存中。
然后，在自己的内存空间改掉之后，还要写回主内存。
这个时候，其他线程并不知道这个值被改了。这个时候，需要有个通知机制，这个就是jmm的通知机制，MESI缓存一致性协议。

本地内存 存着主内存的副本。

不同线程 不能访问对方的 变量。 线程之间的通信必须通过主内存完成。

JMM的可见性（通知机制）



![image-20210310134703415](JMM内存模型.assets/image-20210310134703415.png)



![image-20210310134842914](JMM内存模型.assets/image-20210310134842914.png)

![image-20210310134927573](JMM内存模型.assets/image-20210310134927573.png)

<img src="JMM内存模型.assets/image-20210310135017928.png" alt="image-20210310135017928" style="zoom: 50%;" /><img src="JMM内存模型.assets/image-20210310135105171.png" alt="image-20210310135105171" style="zoom:50%;" />

有个人应该告诉 main  我这边

![image-20210310135307712](JMM内存模型.assets/image-20210310135307712.png)



A线程修改了，写回了主内存，但是main线程不知道



所有加载  现有模版 静态先行 静态值加载一次

静态 >构造块>构造方法



## 有序性

![image-20210907101819844](JMM内存模型.assets/image-20210907101819844.png)

数据依赖性，先得有爹才能有我

![image-20210907102556571](JMM内存模型.assets/image-20210907102556571.png)

![image-20210907102746435](JMM内存模型.assets/image-20210907102746435.png)

不可以

![image-20210907103817813](JMM内存模型.assets/image-20210907103817813.png)



![image-20210907104019773](JMM内存模型.assets/image-20210907104019773.png)

![image-20210907104104866](JMM内存模型.assets/image-20210907104104866.png)

![image-20210907104135384](JMM内存模型.assets/image-20210907104135384.png)









